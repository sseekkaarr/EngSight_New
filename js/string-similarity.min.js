(function (root, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        root.stringSimilarity = factory();
    }
}(this, function () {
    'use strict';

    function compareTwoStrings(str1, str2) {
        if (str1 === str2) return 1; 

        if (str1.length < str2.length) {
            const temp = str1;
            str1 = str2;
            str2 = temp;
        }

        const length1 = str1.length;
        if (length1 === 0) return 0;

        const length2 = str2.length;
        const maxPossibleLength = length1 + length2;
        const editDistance = calculateEditDistance(str1, str2);

        return (length1 - editDistance) / maxPossibleLength;
    }

    function calculateEditDistance(str1, str2) {
        const track = Array.from({ length: str1.length + 1 }, (_, i) => [i]);
        for (let j = 1; j <= str2.length; j++) {
            track[0][j] = j;
        }

        for (let i = 1; i <= str1.length; i++) {
            for (let j = 1; j <= str2.length; j++) {
                const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                track[i][j] = Math.min(
                    track[i - 1][j] + 1,
                    track[i][j - 1] + 1,
                    track[i - 1][j - 1] + indicator
                );
            }
        }

        return track[str1.length][str2.length];
    }

    function findBestMatch(mainString, targetStrings) {
        if (!Array.isArray(targetStrings) || targetStrings.length === 0) {
            throw new Error("Second argument must be a non-empty array of strings.");
        }

        const ratings = targetStrings.map(target => ({
            target,
            rating: compareTwoStrings(mainString, target)
        }));

        ratings.sort((a, b) => b.rating - a.rating);

        return ratings;
    }

    return {
        compareTwoStrings,
        findBestMatch
    };
}));
